{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar stream = require('stream');\n\nfunction Lazy(em, opts) {\n  if (!(this instanceof Lazy)) return new Lazy(em, opts);\n  EventEmitter.call(this);\n  var self = this;\n\n  self.once = function (name, f) {\n    self.on(name, function g() {\n      self.removeListener(name, g);\n      f.apply(this, arguments);\n    });\n  };\n\n  if (!opts) opts = {};\n  var dataName = opts.data || 'data';\n  var pipeName = opts.pipe || 'pipe';\n  var endName = opts.pipe || 'end';\n\n  if (pipeName != endName) {\n    var piped = false;\n    self.once(pipeName, function () {\n      piped = true;\n    });\n    self.once(endName, function () {\n      if (!piped) self.emit(pipeName);\n    });\n  }\n\n  self.push = function (x) {\n    self.emit(dataName, x);\n  };\n\n  self.end = function () {\n    self.emit(endName);\n  };\n\n  if (em && em.on) {\n    em.on(endName, function () {\n      self.emit(endName);\n    });\n    self.on(pipeName, function () {\n      em.emit(pipeName);\n    }); // Check for v0.10 or Greater (Stream2 has Duplex type)\n\n    if (stream.Duplex && em instanceof stream) {\n      em.on('readable', function () {\n        var x = em.read();\n        self.emit(dataName, x);\n      });\n    } else {\n      // Old Stream1 or Event support\n      em.on(dataName, function (x) {\n        self.emit(dataName, x);\n      });\n    }\n  }\n\n  function newLazy(g, h, l) {\n    if (!g) {\n      g = function () {\n        return true;\n      };\n    }\n\n    if (!h) {\n      h = function (x) {\n        return x;\n      };\n    }\n\n    var lazy = new Lazy(null, opts, l);\n    self.on(dataName, function (x, y) {\n      if (g.call(lazy, x)) {\n        lazy.emit(dataName, h(x), y);\n      }\n    });\n    self.once(pipeName, function () {\n      lazy.emit(pipeName);\n    });\n    return lazy;\n  }\n\n  self.filter = function (f) {\n    return newLazy(function (x) {\n      return f(x);\n    });\n  };\n\n  self.forEach = function (f) {\n    return newLazy(function (x) {\n      f(x);\n      return true;\n    });\n  };\n\n  self.map = function (f) {\n    return newLazy(function () {\n      return true;\n    }, function (x) {\n      return f(x);\n    });\n  };\n\n  self.head = function (f) {\n    var lazy = newLazy();\n    lazy.on(dataName, function g(x) {\n      f(x);\n      lazy.removeListener(dataName, g);\n    });\n  };\n\n  self.tail = function () {\n    var skip = true;\n    return newLazy(function () {\n      if (skip) {\n        skip = false;\n        return false;\n      }\n\n      return true;\n    });\n  };\n\n  self.skip = function (n) {\n    return newLazy(function () {\n      if (n > 0) {\n        n--;\n        return false;\n      }\n\n      return true;\n    });\n  };\n\n  self.take = function (n) {\n    return newLazy(function () {\n      if (n == 0) self.emit(pipeName);\n      return n-- > 0;\n    });\n  };\n\n  self.takeWhile = function (f) {\n    var cond = true;\n    return newLazy(function (x) {\n      if (cond && f(x)) return true;\n      cond = false;\n      self.emit(pipeName);\n      return false;\n    });\n  };\n\n  self.foldr = function (op, i, f) {\n    var acc = i;\n    var lazy = newLazy();\n    lazy.on(dataName, function g(x) {\n      acc = op(x, acc);\n    });\n    lazy.once(pipeName, function () {\n      f(acc);\n    });\n  };\n\n  self.sum = function (f) {\n    return self.foldr(function (x, acc) {\n      return x + acc;\n    }, 0, f);\n  };\n\n  self.product = function (f) {\n    return self.foldr(function (x, acc) {\n      return x * acc;\n    }, 1, f);\n  };\n\n  self.join = function (f) {\n    var data = [];\n    var lazy = newLazy(function (x) {\n      data.push(x);\n      return true;\n    });\n    lazy.once(pipeName, function () {\n      f(data);\n    });\n    return self;\n  };\n\n  self.bucket = function (init, f) {\n    var lazy = new Lazy(null, opts);\n\n    var yieldTo = function (x) {\n      lazy.emit(dataName, x);\n    };\n\n    var acc = init;\n    self.on(dataName, function (x) {\n      acc = f.call(yieldTo, acc, x);\n    });\n    self.once(pipeName, function () {\n      lazy.emit(pipeName);\n    }); // flush on end event\n\n    self.once(endName, function () {\n      var finalBuffer = mergeBuffers(acc);\n\n      if (finalBuffer) {\n        yieldTo(finalBuffer);\n      }\n    });\n    return lazy;\n  }; // Streams that use this should emit strings or buffers only\n\n\n  self.__defineGetter__('lines', function () {\n    return self.bucket([], function (chunkArray, chunk) {\n      var newline = '\\n'.charCodeAt(0),\n          lastNewLineIndex = 0;\n      if (typeof chunk === 'string') chunk = new Buffer(chunk);\n\n      if (chunk) {\n        for (var i = 0; i < chunk.length; i++) {\n          if (chunk[i] === newline) {\n            // If we have content from the current chunk to append to our buffers, do it.\n            if (i > 0) {\n              chunkArray.push(chunk.slice(lastNewLineIndex, i));\n            } // Wrap all our buffers and emit it.\n\n\n            this(mergeBuffers(chunkArray));\n            lastNewLineIndex = i + 1;\n          }\n        }\n      }\n\n      if (lastNewLineIndex > 0) {\n        // New line found in the chunk, push the remaining part of the buffer.\n        if (lastNewLineIndex < chunk.length) {\n          chunkArray.push(chunk.slice(lastNewLineIndex));\n        }\n      } else {\n        // No new line found, push the whole buffer.\n        if (chunk && chunk.length) {\n          chunkArray.push(chunk);\n        }\n      }\n\n      return chunkArray;\n    });\n  });\n}\n\nLazy.range = function () {\n  var args = arguments;\n  var step = 1;\n  var infinite = false;\n\n  if (args.length == 1 && typeof args[0] == 'number') {\n    var i = 0,\n        j = args[0];\n  } else if (args.length == 1 && typeof args[0] == 'string') {\n    // 'start[,next]..[end]'\n    var arg = args[0];\n    var startOpen = false,\n        endClosed = false;\n\n    if (arg[0] == '(' || arg[0] == '[') {\n      if (arg[0] == '(') startOpen = true;\n      arg = arg.slice(1);\n    }\n\n    if (arg.slice(-1) == ']') endClosed = true;\n    var parts = arg.split('..');\n    if (parts.length != 2) throw new Error(\"single argument range takes 'start..' or 'start..end' or 'start,next..end'\");\n\n    if (parts[1] == '') {\n      // 'start..'\n      var i = parts[0];\n      infinite = true;\n    } else {\n      // 'start[,next]..end'\n      var progression = parts[0].split(',');\n\n      if (progression.length == 1) {\n        // start..end\n        var i = parts[0],\n            j = parts[1];\n      } else {\n        // 'start,next..end'\n        var i = progression[0],\n            j = parts[1];\n        step = Math.abs(progression[1] - i);\n      }\n    }\n\n    i = parseInt(i, 10);\n    j = parseInt(j, 10);\n\n    if (startOpen) {\n      if (infinite || i < j) i++;else i--;\n    }\n\n    if (endClosed) {\n      if (i < j) j++;else j--;\n    }\n  } else if (args.length == 2 || args.length == 3) {\n    // start, end[, step]\n    var i = args[0],\n        j = args[1];\n\n    if (args.length == 3) {\n      var step = args[2];\n    }\n  } else {\n    throw new Error(\"range takes 1, 2 or 3 arguments\");\n  }\n\n  var lazy = new Lazy();\n  var stopInfinite = false;\n  lazy.on('pipe', function () {\n    stopInfinite = true;\n  });\n\n  if (infinite) {\n    process.nextTick(function g() {\n      if (stopInfinite) return;\n      lazy.emit('data', i++);\n      process.nextTick(g);\n    });\n  } else {\n    process.nextTick(function () {\n      if (i < j) {\n        for (; i < j; i += step) {\n          lazy.emit('data', i);\n        }\n      } else {\n        for (; i > j; i -= step) {\n          lazy.emit('data', i);\n        }\n      }\n\n      lazy.emit('end');\n    });\n  }\n\n  return lazy;\n};\n\nvar mergeBuffers = function mergeBuffers(buffers) {\n  // We expect buffers to be a non-empty Array\n  if (!buffers || !Array.isArray(buffers) || !buffers.length) return;\n  var finalBufferLength,\n      finalBuffer,\n      currentBuffer,\n      currentSize = 0; // Sum all the buffers lengths\n\n  finalBufferLength = buffers.reduce(function (left, right) {\n    return (left.length || left) + (right.length || right);\n  }, 0);\n  finalBuffer = new Buffer(finalBufferLength);\n\n  while (buffers.length) {\n    currentBuffer = buffers.shift();\n    currentBuffer.copy(finalBuffer, currentSize);\n    currentSize += currentBuffer.length;\n  }\n\n  return finalBuffer;\n};\n\nutil.inherits(Lazy, EventEmitter);\nmodule.exports = Lazy;","map":{"version":3,"sources":["C:/Users/deonm/Documents/UNI/React/random-word-gen/node_modules/lazy/lazy.js"],"names":["EventEmitter","require","util","stream","Lazy","em","opts","call","self","once","name","f","on","g","removeListener","apply","arguments","dataName","data","pipeName","pipe","endName","piped","emit","push","x","end","Duplex","read","newLazy","h","l","lazy","y","filter","forEach","map","head","tail","skip","n","take","takeWhile","cond","foldr","op","i","acc","sum","product","join","bucket","init","yieldTo","finalBuffer","mergeBuffers","__defineGetter__","chunkArray","chunk","newline","charCodeAt","lastNewLineIndex","Buffer","length","slice","range","args","step","infinite","j","arg","startOpen","endClosed","parts","split","Error","progression","Math","abs","parseInt","stopInfinite","process","nextTick","buffers","Array","isArray","finalBufferLength","currentBuffer","currentSize","reduce","left","right","shift","copy","inherits","module","exports"],"mappings":"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","sourcesContent":["var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar stream = require('stream');\n\nfunction Lazy(em, opts) {\n    if (!(this instanceof Lazy)) return new Lazy(em, opts);\n    EventEmitter.call(this);\n    var self = this;\n\n\n    self.once = function (name, f) {\n        self.on(name, function g () {\n            self.removeListener(name, g);\n            f.apply(this, arguments);\n        });\n    }\n\n    if (!opts) opts = {};\n    var dataName = opts.data || 'data';\n    var pipeName = opts.pipe || 'pipe';\n    var endName = opts.pipe || 'end';\n\n    if (pipeName != endName) {\n        var piped = false;\n        self.once(pipeName, function () { piped = true });\n        self.once(endName, function () {\n            if (!piped) self.emit(pipeName);\n        });\n    }\n\n    self.push = function (x) {\n        self.emit(dataName, x);\n    }\n\n    self.end = function () {\n        self.emit(endName);\n    }\n\n    if (em && em.on) {\n        em.on(endName, function () {\n            self.emit(endName);\n        });\n        self.on(pipeName, function () {\n            em.emit(pipeName);\n        });\n        // Check for v0.10 or Greater (Stream2 has Duplex type)\n        if (stream.Duplex && em instanceof(stream)) {\n            em.on('readable', function () {\n                var x = em.read();\n                self.emit(dataName, x);\n            });\n        } else {\n            // Old Stream1 or Event support\n            em.on(dataName, function (x) {\n                self.emit(dataName, x);\n            });\n        }\n    }\n\n    function newLazy (g, h, l) {\n        if (!g) {\n            g = function () {\n                return true;\n            };\n        }\n        if (!h) {\n            h = function (x) {\n                return x;\n            };\n        }\n        var lazy = new Lazy(null, opts, l);\n        self.on(dataName, function (x, y) {\n            if (g.call(lazy, x)) {\n                lazy.emit(dataName, h(x), y);\n            }\n        });\n        self.once(pipeName, function () {\n            lazy.emit(pipeName);\n        });\n        return lazy;\n    }\n\n    self.filter = function (f) {\n        return newLazy(function (x) {\n            return f(x);\n        });\n    }\n\n    self.forEach = function (f) {\n        return newLazy(function (x) {\n            f(x);\n            return true;\n        });\n    }\n\n    self.map = function (f) {\n        return newLazy(\n            function () { return true },\n            function (x) { return f(x) }\n        );\n    }\n\n    self.head = function (f) {\n        var lazy = newLazy();\n        lazy.on(dataName, function g (x) {\n            f(x)\n            lazy.removeListener(dataName, g)\n        })\n    }\n\n    self.tail = function () {\n        var skip = true;\n        return newLazy(function () {\n            if (skip) {\n                skip = false;\n                return false;\n            }\n            return true;\n        });\n    }\n\n    self.skip = function (n) {\n        return newLazy(function () {\n            if (n > 0) {\n                n--;\n                return false;\n            }\n            return true;\n        });\n    }\n\n    self.take = function (n) {\n        return newLazy(function () {\n            if (n == 0) self.emit(pipeName);\n            return n-- > 0;\n        });\n    }\n\n    self.takeWhile = function (f) {\n        var cond = true;\n        return newLazy(function (x) {\n            if (cond && f(x)) return true;\n            cond = false;\n            self.emit(pipeName);\n            return false;\n        });\n    }\n\n    self.foldr = function (op, i, f) {\n        var acc = i;\n        var lazy = newLazy();\n        lazy.on(dataName, function g (x) {\n            acc = op(x, acc);\n        });\n        lazy.once(pipeName, function () {\n            f(acc);\n        });\n    }\n\n    self.sum = function (f) {\n        return self.foldr(function (x, acc) { return x + acc }, 0, f);\n    }\n\n    self.product = function (f) {\n        return self.foldr(function (x, acc) { return x*acc }, 1, f);\n    }\n\n    self.join = function (f) {\n        var data = []\n        var lazy = newLazy(function (x) {\n            data.push(x);\n            return true;\n        });\n        lazy.once(pipeName, function () { f(data) });\n        return self;\n    }\n\n    self.bucket = function (init, f) {\n        var lazy = new Lazy(null, opts);\n        var yieldTo = function (x) {\n            lazy.emit(dataName, x);\n        };\n\n        var acc = init;\n\n        self.on(dataName, function (x) {\n            acc = f.call(yieldTo, acc, x);\n        });\n\n        self.once(pipeName, function () {\n            lazy.emit(pipeName);\n        });\n\n        // flush on end event\n        self.once(endName, function () {\n            var finalBuffer = mergeBuffers(acc);\n            if (finalBuffer) {\n                yieldTo(finalBuffer);\n            }\n        });\n\n        return lazy;\n    }\n\n    // Streams that use this should emit strings or buffers only\n    self.__defineGetter__('lines', function () {\n        return self.bucket([], function (chunkArray, chunk) {\n            var newline = '\\n'.charCodeAt(0), lastNewLineIndex = 0;\n            if (typeof chunk === 'string') chunk = new Buffer(chunk);\n        if (chunk){\n            \tfor (var i = 0; i < chunk.length; i++) {\n                \tif (chunk[i] === newline) {\n                    \t// If we have content from the current chunk to append to our buffers, do it.\n                    \t\tif (i > 0) {\n                        \t\tchunkArray.push(chunk.slice(lastNewLineIndex, i));\n                    \t\t}\n\n                    \t\t// Wrap all our buffers and emit it.\n                    \t\tthis(mergeBuffers(chunkArray));\n                    \t\tlastNewLineIndex = i + 1;\n                \t}\n            }\n\t    }\n\n            if (lastNewLineIndex > 0) {\n                // New line found in the chunk, push the remaining part of the buffer.\n                if (lastNewLineIndex < chunk.length) {\n                    chunkArray.push(chunk.slice(lastNewLineIndex));\n                }\n            } else {\n                // No new line found, push the whole buffer.\n                if (chunk && chunk.length) {\n                    chunkArray.push(chunk);\n                }\n            }\n            return chunkArray;\n        });\n    });\n}\n\nLazy.range = function () {\n    var args = arguments;\n    var step = 1;\n    var infinite = false;\n\n    if (args.length == 1 && typeof args[0] == 'number') {\n        var i = 0, j = args[0];\n    }\n    else if (args.length == 1 && typeof args[0] == 'string') { // 'start[,next]..[end]'\n        var arg = args[0];\n        var startOpen = false, endClosed = false;\n        if (arg[0] == '(' || arg[0] == '[') {\n            if (arg[0] == '(') startOpen = true;\n            arg = arg.slice(1);\n        }\n        if (arg.slice(-1) == ']') endClosed = true;\n\n        var parts = arg.split('..');\n        if (parts.length != 2)\n            throw new Error(\"single argument range takes 'start..' or 'start..end' or 'start,next..end'\");\n\n        if (parts[1] == '') { // 'start..'\n            var i = parts[0];\n            infinite = true;\n        }\n        else { // 'start[,next]..end'\n            var progression = parts[0].split(',');\n            if (progression.length == 1) { // start..end\n                var i = parts[0], j = parts[1];\n            }\n            else { // 'start,next..end'\n                var i = progression[0], j = parts[1];\n                step = Math.abs(progression[1]-i);\n            }\n        }\n\n        i = parseInt(i, 10);\n        j = parseInt(j, 10);\n\n        if (startOpen) {\n            if (infinite || i < j) i++;\n            else i--;\n        }\n\n        if (endClosed) {\n            if (i < j) j++;\n            else j--;\n        }\n    }\n    else if (args.length == 2 || args.length == 3) { // start, end[, step]\n        var i = args[0], j = args[1];\n        if (args.length == 3) {\n            var step = args[2];\n        }\n    }\n    else {\n        throw new Error(\"range takes 1, 2 or 3 arguments\");\n    }\n    var lazy = new Lazy;\n    var stopInfinite = false;\n    lazy.on('pipe', function () {\n        stopInfinite = true;\n    });\n    if (infinite) {\n        process.nextTick(function g () {\n            if (stopInfinite) return;\n            lazy.emit('data', i++);\n            process.nextTick(g);\n        });\n    }\n    else {\n        process.nextTick(function () {\n            if (i < j) {\n                for (; i<j; i+=step) {\n                    lazy.emit('data', i)\n                }\n            }\n            else {\n                for (; i>j; i-=step) {\n                    lazy.emit('data', i)\n                }\n            }\n            lazy.emit('end');\n        });\n    }\n    return lazy;\n}\n\nvar mergeBuffers = function mergeBuffers(buffers) {\n  // We expect buffers to be a non-empty Array\n  if (!buffers || !Array.isArray(buffers) || !buffers.length) return;\n\n  var finalBufferLength, finalBuffer, currentBuffer, currentSize = 0;\n\n  // Sum all the buffers lengths\n  finalBufferLength = buffers.reduce(function(left, right) { return (left.length||left) + (right.length||right); }, 0);\n  finalBuffer = new Buffer(finalBufferLength);\n  while(buffers.length) {\n    currentBuffer = buffers.shift();\n    currentBuffer.copy(finalBuffer, currentSize);\n    currentSize += currentBuffer.length;\n  }\n\n  return finalBuffer;\n}\n\n\nutil.inherits(Lazy, EventEmitter);\nmodule.exports = Lazy;\n"]},"metadata":{},"sourceType":"script"}